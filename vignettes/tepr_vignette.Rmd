---
title: "TepR: Transcription elongation profile in R"
author: "Victor Billon, Nicolas Descostes, and Gael Cristofari"
package: tepr
output:
    BiocStyle::html_document
vignette: >
    %\VignetteIndexEntry{tepr}
    %\VignetteEngine{knitr::rmarkdown}
    %\VignetteEncoding{UTF-8}
---


# Introduction

TepR (Transcription Elongation Profile in R) is an R package designed for analyzing data from nascent RNA sequencing technologies, such as TT-seq, mNET-seq, and PRO-seq.  It calculates the probability distribution of nascent RNA sequencing signal across the gene body or transcription unit of a given gene.  By comparing this profile to a uniform signal, TepR can identify transcription attenuation sites.  Furthermore, it can detect increased or decreased transcription attenuation by comparing profiles across different conditions.  Beyond its rigorous statistical testing and high sensitivity, a key strength of TepR is its ability to resolve the elongation pattern of individual genes, including the precise location of the primary attenuation point, when present.  This capability allows users to visualize and refine genome-wide aggregated analyses, enabling the robust identification of effects specific to gene subsets.  These metrics facilitate comparisons between genes within a condition, across conditions for the same gene, or against a theoretical model of perfect uniform elongation.

# Getting help

For any questions or bug reports, please open an [issue](https://github.com/retrogenomics/tepr/issues) on GitHub.

# Quick start

The following example demonstrates a complete run of the package. Preprocessing is performed on chromosome 13, and postprocessing is limited to the first 100 transcripts. The system.file command retrieves file paths from the package's "extdata" directory.

```{r quickstart, eval = FALSE}

library(tepr)

## Parameters (transpath limited to 100 transcripts)
exppath <-  system.file("extdata", "exptab.csv", package="tepr")
transpath <- system.file("extdata", "cugusi_100.tsv", package="tepr")
expthres <- 0.1
windsize <- 200

## Read input tables
expdf <- read.csv(exppath)
transdf <- read.delim(transpath, header = FALSE)

## Retrieving the bedgraph paths
bgpathvec <- sapply(expdf$path, function(x) system.file("extdata", x,
    package = "tepr"))

## Replace the path column of expdf with the previously retrieved paths
## and writing the new experiment file to the current folder
expdf$path <- bgpathvec
write.csv(expdf, file = "./exptab.csv", row.names = FALSE, quote = FALSE)
exppath <- "./exptab.csv"


#########
# Pre-processing - takes ~ 7 minutes
#########

gencodepath <- system.file("extdata", "gencode-chr13.gtf", package = "tepr")
maptrackpath <- system.file("extdata", "k50.umap.chr13.hg38.0.8.bed",
    package = "tepr")
blacklistshpath <- system.file("extdata", "hg38-blacklist-chr13.v2.bed",
    package = "tepr")
genomename <- "hg38"

finaltab <- preprocessing(exppath, gencodepath, windsize, maptrackpath,
    blacklistshpath, genomename, finaltabpath = "./", finaltabname = "anno.tsv",
    showtime = TRUE, verbose = TRUE)

#########
# tepr analysis - takes ~ 11 seconds
#########

reslist <- tepr(expdf, transdf, expthres, showtime = TRUE, verbose = TRUE)
resmeandiff <- reslist[[1]]
res <- reslist[[2]]
```

# Data

## Description

For a comprehensive analysis, we will use the data from [Cugusi et al.](https://doi.org/10.1016/j.molcel.2022.01.007). To validate our approach and explore the utility of TepR metrics in revealing gene-specific elongation characteristics, we re-analyzed previous experiments demonstrating that heat shock (HS) induces attenuation in human cultured cells.  We compared TT-seq data from HS-stressed and control MRC5-VA cells.  Stressed cells were cultured for 2 hours at 42°C, while control cells were maintained at 37°C.  Both samples were subjected to a 15-minute pulse of 4-thiouridine (4sU) labeling of nascent transcripts, followed by purification and sequencing.

## Download

The bedgraph files, mappability track and black list necessary for performing the entire analysis can be downloaded from zenodo:

```{bash raw-files, eval = FALSE}

TO DO
-----

#!/usr/bin/sh

mkdir data

wget https://ftp.ebi.ac.uk/pub/databases/gencode/Gencode_human/release_43/gencode.v43.basic.annotation.gtf.gz -P data/ && gunzip data/gencode.v43.basic.annotation.gtf.gz
wget https://github.com/Boyle-Lab/Blacklist/blob/master/lists/hg38-blacklist.v2.bed.gz -P data/ && gunzip data/hg38-blacklist.v2.bed.gz

* k50.umap.hg38.0.8.bed (k50.umap.hg38.0.8.bed) - sent by victor
* ctrl_rep1.forward.bg (ctrl_rep1.forward.bg) - sent by victor
* ctrl_rep1.reverse.bg (ctrl_rep1.reverse.bg) - sent by victor
* ctrl_rep2.forward.bg (ctrl_rep2.forward.bg) - sent by victor
* ctrl_rep2.reverse.bg (ctrl_rep2.reverse.bg) - sent by victor
* HS_rep1.forward.bg (HS_rep1.forward.bg) - sent by victor
* HS_rep1.reverse.bg (HS_rep1.reverse.bg) - sent by victor
* HS_rep2.forward.bg (HS_rep2.forward.bg) - sent by victor
* HS_rep2.reverse.bg (HS_rep2.reverse.bg) - sent by victor

```

If one would like to skip the preprocessing, the preprocessing result file can be downloaded with:

```{bash cugusi-table, eval = FALSE}

TO DO
```


# Standard workflow

## Preprocessing

The preprocessing pipeline consists of the following steps:

1.  Filtering Gencode annotations to extract "transcript" annotations.
2.  Distinguishing between protein-coding (MANE_Select) and long non-coding (lncRNA, Ensembl_canonical) transcripts.
3.  Dividing transcripts into windows of a user-defined size (`windsize`).
4.  Processing bedgraph files to retrieve signal values, excluding blacklisted regions, and retaining scores within high-mappability intervals.
5.  Generating a final annotated table incorporating the scores derived from the preceding steps.

**Important:** The `preprocessing` function allows for saving intermediate objects, which prevents recomputation in cases of failure due to memory or time constraints.  See the `saveobjectpath` and `deletetmp` parameters in the `?preprocessing` help documentation for details.  Resource requirements for processing the complete dataset are provided below.

| nb CPU | RAM | Time |
|--------|-----|------|
| 15 | 113.5 G | 3h47 |
| 10 | 78.9 G | 4h24 |
| 7 | 57.4 G | 5h27 |
| 5 | 43G | 6h58 |
| 3 | 28.7G | 9h02|

The code below is executed on chromosome 13 only to reduce computation time.

### Input files

The following input files are required for the analysis:

*   **exptab:** A table describing the experiments, containing the columns "condition," "replicate," "direction," "strand," and "path." The "direction" column should contain the values "forward" and "reverse," and the "strand" column should contain "plus" and "minus."  The `checkexptab` utility function can be used to verify the table's format.
*   **gencode:** The Gencode annotation file, available at [https://www.gencodegenes.org/](https://www.gencodegenes.org/).
*   **maptrack:** Files containing low-mappability intervals for the genome of interest. For hg38, the track [k50.Unique.Mappability.bb](https://hgdownload.soe.ucsc.edu/gbdb/hg38/hoffmanMappability/k50.Unique.Mappability.bb) was downloaded from the UCSC server, and scores below 0.8 were set to `NA`.
*   **blacklist:** Blacklist files for various organisms are available at [https://github.com/Boyle-Lab/Blacklist/blob/master/lists/](https://github.com/Boyle-Lab/Blacklist/blob/master/lists/).


### Retrieving Transcript Annotations from Gencode

The `retrieveanno` function performs the following steps:

1.  Reads and validates experimental data from the provided `exptab` CSV file.
2.  Reads genomic annotations from the Gencode file and filters for "transcript" entries.
3.  Processes protein-coding and long non-coding RNA (lncRNA) transcripts separately:
    *   For protein-coding genes, it selects the most representative transcript (MANE_Select or Ensembl_canonical).
    *   For lncRNAs, it filters out transcripts with undesirable evidence levels (containing keywords "not_best_in_genome_evidence," "transcript_support_level 5," or "transcript_support_level 4").
4.  Combines the processed annotations into a single data frame, labeling each transcript with its biotype (protein-coding or lncRNA).
5.  Optionally saves the resulting data frame as an RDS file in the specified `saveobjectpath` directory.
6.  Optionally reports the total analysis time (if `showtime = TRUE`).


```{r retrieveanno}
library(tepr)

## Parameters
exptabpath <-  system.file("extdata", "exptab.csv", package="tepr")
gencodepath <- system.file("extdata", "gencode-chr13.gtf", package = "tepr")

allannobed <- retrieveanno(exptabpath, gencodepath)
message("\n The result is:\n")
print(head(allannobed, 3))
```

### Defining windows for each transcript

`makewindows` removes any ensembl names containing "PAR_Y". It filters out intervals smaller than windsize and splits each transcript into "windsize" windows. The result includes metadata for each window, such as its chromosome, start and end coordinates, associated gene, and the window number.

```{r makewindows}
## Parameters
windsize = 200

allwindowsbed <- makewindows(allannobed, windsize)
message("\n The result is:\n")
print(head(allwindowsbed, 3))
```

### Retrieving bedgraph scores, removing those in black list and low mappability intervals

The `blacklisthighmap` function iterates through chromosomes, processes genomic scores by removing those overlapping with blacklisted and low-mappability regions, and ensures that scores within windows are computed using a weighted mean. The function uses parallel processing for efficiency and supports saving (saveobjectpath) and reloading (reload) intermediate results to optimize workflow.

The main steps include:
 - Reading and processing bedGraph values.
 - Removing scores overlapping with blacklisted and low mappability regions.
 - Computing weighted means for overlapping scores in genomic windows.
 - Saving the processed results to specified path (tmpfold).

Note that no result is returned but files are saved to a temporary folder. These files will be used by the following function `createtablescores`.

```{r blacklisthighmap, eval = FALSE}
## Parameters
maptrackpath <- system.file("extdata", "k50.umap.chr13.hg38.0.8.bed", package = "tepr")
blacklistshpath <- system.file("extdata", "hg38-blacklist-chr13.v2.bed", package = "tepr")
nbcputrans <- 1
genomename <- "hg38"
tmpfolder <- "./tmp"

## The path to the bedgraph files provided with the package depends on your installation. Modify exptab with the\
## correct path and create a new file in the current folder.
## IMPORTANT: You can skip these steps if your exptab contains the correct paths
expdf <- read.csv(exptabpath)
bgpathvec <- sapply(expdf$path, function(x) system.file("extdata", x,
    package = "tepr"))
expdf$path <- bgpathvec
write.csv(expdf, file = "./exptab.csv", row.names = FALSE, quote = FALSE)
exptabpath <- "./exptab.csv"

## Retrieving bedgraph scores, removing those in black list and low mappability intervals
blacklisthighmap(maptrackpath, blacklistshpath, exptabpath, nbcputrans, allwindowsbed, windsize, genomename, tmpfold = tmpfolder)
```

### Create the final table

This function merges files stored in `tmpfolder` and belonging to the same experiment and direction. These files are combined into a single table providing two columns per experiment. The first gives the name of the experiment and the second the scores. The resulting table also includes annotations for each transcript.

```{r createtablescores, eval = FALSE}
finaltab <- createtablescores(tmpfolder, exptabpath, savefinaltable = FALSE)
```

The final table should look like:

```{r showfinaltab, echo = FALSE}
finaltabpath <- system.file("extdata", "finaltab-chr13.tsv", package = "tepr")
finaltab <- read.delim(finaltabpath, header = FALSE)
print(finaltab)
```

## tepr analysis

In the quick start section, it is indicated how to perform the tepr analysis in one call with the `tepr` function. Below, the different steps performed by `tepr` are detailed with the toy-data limited to 100 transcripts. For the plots, the figures obtained running the functions on the complete annotations are also provided. The complete table resulting from the preprocessing can be downloaded at `TO DO`. You can find a note on processing the complete dataset in section XXX.

### Input files

Two tables are needed as input:

- **transdf**: Table obtained with the `preprocessing` function (see previous sections). It contains information about each experiment along with scores, for each protein-coding and lncRNA annotations. 

- **exptab**: Table describing the experiments. It contains the columns "condition", "replicate", "direction", "strand", and "path". The column "direction" should contain the values "forward" and "reverse". The column "strand" should contain the values "plus" and "minus". You can check the conformity of the table with the utility function    `checkexptab`. 

The two tables are provided with the package and can be retrieved with the command `system.file` in the folder “extdata”. We sampled 100 transcripts from the transdf table to describe the pipeline in order to reduce computation time. 

```{r reading-anno-scores}
transpath <- system.file("extdata", "cugusi_100.tsv", package="tepr")
transdf <- read.delim(transpath, header = FALSE)
colnames(transdf) <- c("biotype", "chr", "coor1", "coor2", "transcript", "gene",
    "strand", "window", "id", "ctrl_rep1.plus", "ctrl_rep1.plus_score",
    "ctrl_rep1.minus", "ctrl_rep1.minus_score", "ctrl_rep2.plus",
    "ctrl_rep2.plus_score", "ctrl_rep2.minus", "ctrl_rep2.minus_score",
    "HS_rep1.plus", "HS_rep1.plus_score", "HS_rep1.minus",
    "HS_rep1.minus_score", "HS_rep2.plus", "HS_rep2.plus_score",
    "HS_rep2.minus", "HS_rep2.minus_score")
print(head(transdf, 3))

## The second table contains information about each replicate:
exppath <- system.file("extdata", "exptab.csv", package="tepr")
expdf <- read.csv(exppath)
head(expdf)
```

You can verify the conformity of the table with the utility function `checkexptab`. Note that this verification step is also performed by `averageandfilterexprs`.

```{r checkexptab}
checkexptab(expdf)
```

### Expressed transcripts and average expression

In order to study changes in patterns of nascent RNA, the first step is to select expressed transcripts. The expression value of a gene is defined as the mean score on each strand. Scores were extracted from bedgraphs. A gene is considered as expressed if all condition means are above a given expression threshold. The threshold above which a gene is considered as expressed is set to 0.1 by default.

```{r averageandfilterexprs}
## Calculate Average Expression and Filter Transcript Data
expthres <- 0.1
resallexprs <- averageandfilterexprs(expdf, transdf, expthres)
```

`resallexprs` is a list which first element contains `transdf` with added columns such as means. The second element contains a vector of the transcripts considered as expressed. This vector will be used for further downstream analyses.

```{r exprsvec}
## Print the first 6 expressed transcripts
head(resallexprs[[2]])
```


### NA values per transcript and condition

During the preprocessing, scores falling in intervals belonging to the user-defined black list, low mappability regions of the genome, or any regions to exclude are replaced by NA. The function `countna` enables to retrieve the number of missing scores per transcript. This table can be used for further filtering of the data, such as filtering out transcripts with too many windows without scores.

```{r countna}
## Count NA values per transcript and condition
rescountna <- countna(resallexprs, expdf)
head(rescountna)
```

### ECDF for Genes Based on Expression Data

This function calculates the empirical cumulative distribution function (ECDF) for expressed genes across transcripts. An ECDF is a probability distribution that is an estimator of the Cumulative Distribution Function, here we use the ecdf() function from R. It creates an ECDF for each transcript, which are then used to evaluate differences in signal with a Kolsmogorov-Smirnov test. The ECDF enables us to answer the question: How likely is it that we would see a distibution of signals like this if these signals were drawn from a uniform probability distribution? In other words, this statistics enables to identify specific loci from where transcription signal differs significantly from a uniform density. In the following steps, the ECDF is used to compute the difference with the cumulative distribution (see `meananddifference`), which is subsequently used to calculate the area under the curve (AUC, see `allauc`) and the inflection point or knee (see `kneeid`).  


```{r ecdf}
## Compute ECDF for Genes Based on Expression Data
resecdflist <- genesECDF(resallexprs, expdf)
```

The genesECDF function returns a list which first element is the main table with additional ecdf columns denoted with the `Fx` prefix.

```{r resecdf}
resecdf <- resecdflist[[1]]
print(head(as.data.frame(resecdf), 3))
```

The second element returns the number of windows per transcript that is set to 200 by default during the pre-processing.

```{r nbwindows}
nbwindows <- resecdflist[[2]]
print(nbwindows)
```


### Mean and Differences of Scores for Each Condition

The function `meandifference` computes three types of statistics, the mean values of scores, the ecdf for each replicate (if provided), and difference of mean ecdf with the uniform cumulative distribution respectively. The mean values between replicates implies that one column `mean_value` per condition will be returned. The score `mean_value` column(s) are necessary to calculate the attenuation scores later on (see `attenuation`). The ecdf `mean_value` are used to computes a difference with the cumulative distribution that we call *diff_Fx*. The
*diff_Fx* statistics enables to calculate the area under the curve (AUC, see `allauc`) and the inflection point or *knee* (see `kneeid`).

The difference is defined as: *diff_Fx = meanECDF - cumvec / nbwindows*

```{r meandifference}
## Compute Mean and Differences of Scores for Each Condition
resmeandiff <- meandifference(resecdf, expdf, nbwindows)
print(head(resmeandiff, 3))
```

The result table is then splitted into a list of table per transcript. This enables to further perform operations by transcripts in parallel if more than one cpu is used.

```{r splitmeans}
## Split the results by transcripts
bytranslistmean <- split(resmeandiff, factor(resmeandiff$transcript))
```


### Area Under Curve (AUC) and Differences of AUC for Transcript Data

The AUC values enable the comparison of the nascent-rna signal with a uniform distribution (no attenuation of signal, x = y), or to compare the difference in signal distribution between two conditions (dAUC). The difference between cumulative densities is estimated by a Kolmogorov-Smirnov test with adjusted p-value. Finally, results are returned by transcript along with a mean value that is called *MeanValueFull*.

For each condition (if more than one), the Area Under the Curve (AUC) of *diff_Fx* (see previous section) is computed with a trapezoidal approximation (see pracma::trapz):

*AUC = pracma::trapz(transcoord, diff_Fx)*

with transcoord being the positions along the transcript and *diff_Fx* the difference with the cumulative distribution.


```{r allauc}
## Calculate Area Under Curve (AUC) and Differences of AUC for Transcript Data
resauc <- allauc(bytranslistmean, expdf, nbwindows)
print(head(resauc, 3))
```

### Knee and Max ECDF Differences for Each Transcript

To assess attenuation in nascent-rna signal, one must identify a significant change in signal distribution. To acheive this, tepr identifies the maximum *diff_Fx*. In other words, it identifies the maximum variation in the signal progression of the empirical cumulative distribution (see `genesECDF` and `meandifference`). The window where maximum change is observed is termed *knee* and is calculated as: *knee = max(diff_Fx)*. Thus, the knee position is defined as the max difference between the ecdf and the y=x curve.

The function returns the position (*Knee_AUC*) and the value (*diff_Fx*) of the knee.

```{r knee}
## Identify the Knee and Max ECDF Differences for Each Transcript
resknee <- kneeid(bytranslistmean, expdf)
print(head(resknee))
```

### Attenuation

The `attenuation` function calculates the mean value of all window mean scores before and after the knee location. It then provides an "attenuation score" with the formula: *att <- 100 - downmean / upmean x 100* (x for multiplication). The three values *att*, *downmean*, and *upmean* are provided by the columns "UP_mean_", "DOWN_mean_", and "Attenuation_".

```{r attenuation}
## Calculate Attenuation from AUC and Other Transcript Features
resatt <- attenuation(resauc, resknee, rescountna, bytranslistmean, expdf,
    resmeandiff)
print(head(resatt, 3))
```

### Universe and Group

**Universe**

Before further downstream analysis, the list of transcript to study must be defined. These transcripts are labeled as belonging to the Universe. tepr selects a transcript if:

1. Its windows are long enough.
2. It does not contain too many missing values (NA).
3. Its mean expression value is high enough.
4. It has a significant Kolmogorov-Smirnov test adjusted p-value. The test was performed between the ecdf distribution and the theoretical cumulative distribution.

Analytically it gives:

```{r uniselect, eval = FALSE}
window_size > windsizethreshold &
Count_NA < countnathreshold &
meanctrl > meanctrlthreshold &
meanstress > meanstressthreshold &
pvaltheory > pvaltheorythres
```

If only one condition is given, only the control threshold is used:

```{r uniselectonecond, eval = FALSE}
window_size > windsizethreshold &
Count_NA < countnathreshold &
meanctrl > meanctrlthreshold &
pvaltheory > pvaltheorythres
```

What a satisfying threshold for each criterion is depends on the experiments. The user can adjust the different threshold along the analysis. A transcript satisfying the above criterion is defined as belonging to the `Universe` of the transcripts to analyze (Universe column contains TRUE or FALSE).

**Group**

The transcripts of the Universe are further divided into `Group`. A transcript belongs to the "Attenuated" group if:

1. It belongs to the Universe (TRUE).
2. The "stress" AUC value is high enough.
3. The `-log10` of the adjusted p-value of the Kolmogorov-Smirnov test is above a given threshold.

Analytically it gives:

```{r attselect, eval = FALSE}
Universe == TRUE &
aucstress > aucstressthreshold &
-log10(pvalks) > attenuatedpvalksthreshold
```

If one condition is provided, no comparison by ks test with another condition was performed. A transcript will be considered as attenuated if it differs significantly from the theoretical cumulative distribution and if its AUC value is high enough. The differing status has been evaluated when computing the Universe column above (pvaltheory > pvaltheorythres). Therefore, for one condition, a transcript is considered as attenuated if:

```{r attselectonecond, eval = FALSE}
Universe == TRUE & aucctrl > aucctrlthreslower
```

A transcript is considered as non-attenuated ("Outgroup") if:

1. The Kolmogorov-Smirnov adjusted p-value is above a threshold.
2. The control AUC is between two user-defined thresholds.

Analytically it gives:

```{r outgroup, eval = FALSE}
Universe == TRUE & pvalks > outgrouppvalksthreshold &
aucctrl > aucctrlthresoldhigher & aucctrl < aucctrlthresholdlower
```

For one condition, no ks test was performed against another. Therefore we define a transcript as belonging to 'Outgroup' if it belongs to the Universe and the control AUC is between two user-defined thresholds:

```{r outgroup2, eval = FALSE}
Universe == TRUE & aucctrl > aucctrlthresoldhigher & aucctrl < aucctrlthresholdlower
```
Note that transcripts belonging neither to "Attenuated" nor "Outgroup" are NA. The columns `Universe` and `Group` are computed with:

```{r universegroup}
## Define Universe and Group of Genes Based on Expression Data
res <- universegroup(resatt, expdf)
print(head(res, 2))
```


## Plotting

tepr enables the visualization of the cumulative transcription density along a selected transcription unit (`plotecdf`); the comparison of the AUC between two conditions (`plotauc`); the average transcription density of a user-selected collection of transcripts (`plotmetagenes`); and of the histogram of the distance of the knees to the transcription start sites (TSS).

### plotecdf

The visualization of the ecdf probability distribution for a particular transcript (here EGFR) can be obtained with:

```{r plotecdf}
colvec <- c("#90AFBB", "#10AFBB", "#FF9A04", "#FC4E07")
plotecdf(resmeandiff, res, expdf, "EGFR", colvec, plot = TRUE)
```

### plotauc

The AUC values between conditions can be compared by highlighting the two conditions on the plot:

```{r plotaucgroups}
plotauc(res, expdf, plottype = "groups", plot = TRUE)
```

The plot on the complete dataset gives:

<img src="pictures/AUCcompare_group.png" alt="AUC group plot" width="400"/>

It is also possible to compare the AUC by coloring points according to the Kolmogorov-Smirnov test adjusted p-values and by indicating graphically the points corresponding to a group of genes (here defined by `genevec`):

```{r plotaucpval}
genevec <- c("EGFR", "DAP", "FLI1", "MARCHF6", "LINC01619")
plotauc(res, expdf, genevec, plot = TRUE)
```

The plot on the complete dataset gives:

<img src="pictures/AUCcompare_pval.png" alt="AUC pval plot" width="400"/>


### plotmetagenes

The average transcription density along a meta-transcript or a meta-gene can be visualized with:

```{r metageneplot}
plotmetagenes(res, resmeandiff, expdf, plottype = "attenuation", plot = TRUE)
```

The plot on the complete dataset gives:

<img src="pictures/metagene_attenuation.png" alt="Attenuation meta" width="400"/>

Note that the second parameter tells to plot the distribution for the transcripts identified as "attenuated" by the function `universegroup`. The function also enables to select the transcripts categorized as "outgroup", all the transcripts belonging to the "universe", or all the transcripts of the initial table ("all").

### plothistoknee

One can visualize the distance of the knees from the TSS by percentage:

```{r kneepercent}
plothistoknee(res, plot = TRUE)
```

The plot on the complete dataset gives:

<img src="pictures/histo_percent.png" alt="histo percent" width="400"/>

The distance can also be visualised in kilobases (kb) by changing the *plottype* parameter to "kb":

```{r kneekb}
plothistoknee(res, plottype = "kb", plot = TRUE)
```

The plot on the complete dataset gives:

<img src="pictures/histo_kb.png" alt="histo kb" width="400"/>

## More than two conditions

### teprmulti analysis

It is possible to analyze more than two experiments with the function `teprmulti`. This function performs a "all vs all" analysis and returns a list whose elements, for each comparison, is a list of two data frames: 

- `resmeandiff_<comparison>`: Results of the `meandifference` function for the specific two condition comparison.
- `resunigroupatt_<comparison>`: Results from the `universegroup` function for the specific two condition comparison. 

```{r teprmulti, eval = FALSE}
resteprmulti <- teprmulti(expdf, transdf, expthres)
```

The function `showallcomp` enables to return a vector of all comparison names that will be performed by `teprmulti`. This gives the possibility to reduce the number of comparisons by using the `dontcompare` parameter. `dontcompare` takes a vector of all the comparisons to exclude. The code below limits teprmulti to three comparisons:

```{r teprmultithree, eval = FALSE}
## Returns a vector with all the comparison names to exclude
dontcompvec <- showallcomp(expdf)
dontcompvec <- dontcompvec[- c(1,2,3)]

resteprmulti <- teprmulti(expdf, transdf, expthres, dontcompare = dontcompvec)
```


### plotmulti

Using the result list `resteprmulti`, all plots for all comparisons can be generated with `plotmulti`. The function goes through each element of `resteprmulti` which corresponds to a comparison of two conditions. For each element it calls the following functions:

- `plotecdf`: The function generates a figure for each gene given in ecdfgenevec.
- `plotauc`: Generates figures by groups and pval. The lattest figure is not generated if genaucvec = NA.
- `plotmetagenes`: Generates the figures by attenuation, outgroup, universe, and all.
- `plothistoknee`: Generate the figures by percent and kb.

Figures are written to `outfold` and subfolders are automatically created with the names of the comparisons.

```{r plotmulti, eval = FALSE}
plotmulti(resteprmulti, expdf, ecdfgenevec = c("CDC27", "BCAR1", "TRAM2"), outfold = "./multicomp")
```

### Calculating knee for each condition

The function `kneeallconds` aims at retrieving knee values without having to perform the entire `teprmulti` analysis. It computes the knee values `knee_AUC_` and `max_diff_Fx_` for each condition separately.

```{r kneeallconds, eval = FALSE}
kneedf <- kneeallconds(alldf, expdf, expthres)
```


## Single condition

If your dataset contains only one condition, either with one or more than one replicate, it is possible to analyse the data by comparing the signal to a linear "theoretical" distribution representing a uniform signal. The difference of means and AUC are skipped when running `meandifference` and `allauc`. The criterion to define the columns "Universe" and "Group" are also different (see details in previous section). 

```{r singlecond}
## The experiment table is limited to one condition and one replicate
expdfonecond <- expdf[which(expdf$condition == "HS" & expdf$replicate == 1), ]

## The table obtained by preprocessing is limited to the condition 'HS' and replicate 1
transdfonecond <- transdf[, c(seq_len(9), 18, 19, 20, 21)]

## Computing the object 'res' with tepr on one condition
resonecond <- tepr(expdfonecond, transdfonecond, expthres, controlcondname = "HS", verbose = FALSE)
```

The AUC and metagene plots require two conditions and thus cannot be generated. The ecdf on a given gene can be obtained with:

```{r ecdfcond}
plotecdf(resonecond[[1]], resonecond[[2]], expdfonecond, genename = "EGFR",
    colvec = c("#90AFBB"), plot = TRUE)
```

The histogram of knee positions can be obtained with:

```{r histocond}
## Randomly marking 10 transcripts as attenuated as a mock example
idxatt <- sample(seq_len(100), 10)
resonecond[[2]][idxatt, "Group"] <- "Attenuated"
plothistoknee(resonecond[[2]], kneename = "knee_AUC_HS", plottype = "percent", plot = TRUE)
```

# Annex

## Note on processing the complete dataset

Note that parallelization is encouraged on the complete dataset. We used 20 cpus. The code below assumes that the file "dTAG_Cugusi_stranded_20230810.tsv" is in the current folder. Note that you can check the conformity of the table `transdf` with the utility function `checkexptab`. 

The time of computation for each function is indicated:

```{r completedataset, eval = FALSE}
library(tepr)

transpath <- "dTAG_Cugusi_stranded_20230810.tsv"
exppath <- system.file("extdata", "exptab.csv", package="tepr")

## Reading input files
transdf <- read.delim(transpath, header = FALSE) 
expdf <- read.csv(exppath)

## Calculate Average Expression and Filter Transcript Data
expthres <- 0.1
resallexprs <- averageandfilterexprs(expdf, transdf, expthres, showtime = TRUE)

         Calculating average expression per transcript
         Removing lines with values < expthres
                 ## Analysis performed in: 7.67012810707092 (seconds)

## Count NA values per transcript and condition
rescountna <- countna(resallexprs, expdf, nbcpu = 20, showtime = TRUE)

         Splitting the table by each transcript
                 ## Analysis performed in: 25.9511797428131 (seconds)

## Compute ECDF for Genes Based on Expression Data
resecdflist <- genesECDF(resallexprs, expdf, nbcpu = 20, showtime = TRUE)

         Filtering to keep only the expressed transcripts
         Splitting the table by each transcript
         Computing ecdf on each transcript
                 ## Analysis performed in: 1.23920369148254 (minutes)
resecdf <- resecdflist[[1]]
nbwindows <- resecdflist[[2]]

## Compute Mean and Differences of Scores for Each Condition
resmeandiff <- meandifference(resecdf, expdf, nbwindows, showtime = TRUE)

         Merging columns for condition ctrl
         Calculating average and difference between replicates for columns 'value' of ctrl
         Calculating average and difference between replicates for columns 'Fx' of ctrl
         Merging columns for condition HS
         Calculating average and difference between replicates for columns 'value' of HS
         Calculating average and difference between replicates for columns 'Fx' of HS
         Commputing all differences on mean columns
                 ## Analysis performed in: 0.953349590301514 (seconds)

## Split the results by transcripts
start_time <- Sys.time()
bytranslistmean <- split(resmeandiff, factor(resmeandiff$transcript))
end_time <- Sys.time()
message("\t\t ## Analysis performed in: ", end_time - start_time)

                ## Analysis performed in: 6.54691791534424 (seconds)

## Calculate Area Under Curve (AUC) and Differences of AUC for Transcript Data
resauc <- allauc(bytranslistmean, expdf, nbwindows, nbcpu = 20, showtime = TRUE)

         Computing the differences (d or delta) of AUC
         Computing the Area Under Curve (AUC)
         Merging results
                 ## Analysis performed in: 27.2096176147461 (seconds)

## Identify the Knee and Max ECDF Differences for Each Transcript
resknee <- kneeid(bytranslistmean, expdf, nbcpu = 20, showtime = TRUE)

                 ## Analysis performed in: 11.8020555973053 (seconds)

## Calculate Attenuation from AUC and Other Transcript Features
resatt <- attenuation(resauc, resknee, rescountna, bytranslistmean, expdf,
    resmeandiff, nbcpu = 20, showtime = TRUE)

         Merging tables
         Building summary
         Merging summary
         Merging detailed mean table with summary
         Splitting the previous table by transcript
         Computing up and down mean
         Merging attenuation to the complete table
                 ## Analysis performed in: 1.17459278106689 (minutes)

## Define Universe and Group of Genes Based on Expression Data
res <- universegroup(resatt, showtime = TRUE)

         Computing the Universe column
         Computing the Group column
                          ## Analysis performed in: 0.0214207172393799 (seconds)

## Plotting and saving to current folder
colvec <- c("#90AFBB", "#10AFBB", "#FF9A04", "#FC4E07")
plotecdf(resmeandiff, res, expdf, "EGFR", colvec, outfold = ".",
    formatname = "png")

plotauc(res, expdf, plottype = "groups", outfile = "AUCcompare_group", outfold = ".",
    formatname = "png")
genevec <- c("EGFR", "DAP", "FLI1", "MARCHF6", "LINC01619")
plotauc(res, expdf, genevec, plottype = "pval", outfile = "AUCcompare_pval",
    outfold = ".", formatname = "png")

plotmetagenes(res, resmeandiff, expdf, plottype = "attenuation", formatname = "png",
    outfold = ".")

plothistoknee(res, outfold = ".", formatname = "png")
plothistoknee(res, plottype = "kb", outfold = ".", formatname = "png")
```


## Preprocessing with bash

To perform the pre-processing steps, we provide a conda environment that can be activated with:

```{bash conda, eval = FALSE}
TO DO
```

Retrieve the protein-coding and long non-coding RNA (lncRNA) annotations from the gencode file:

```{bash protcod-lncrna, eval = FALSE}
#!/usr/bin/sh

cd data/

## Building the protein-coding bed file
grep -w transcript gencode.v43.basic.annotation.gtf | grep -w MANE_Select > MANE_Select.protein_coding.gtf
awk 'OFS="\t" {print $0}' MANE_Select.protein_coding.gtf | tr -d '";' | sort -k1,1 -k2,2n  | awk -F \t -v OFS='\t' '{print $0}' | awk -v OFS="\t" '{ print $1,$4,$5,$12,$16,$7}' > MANE_Select.protein_coding.bed

## Building the lncRNA bed file
grep -w transcript gencode.v43.basic.annotation.gtf | grep -w lncRNA | grep -w Ensembl_canonical | grep -v not_best_in_genome_evidence | grep -v 'transcript_support_level "5"' | grep -v 'transcript_support_level "4"' > Ensembl_canonical_TSL123.lncRNA.gtf
awk 'OFS="\t" {print $0}' Ensembl_canonical_TSL123.lncRNA.gtf | tr -d '";' | sort -k1,1 -k2,2n  | awk -F \t -v OFS='\t' '{print $0}' | awk -v OFS="\t" '{ print $1,$4,$5,$12,$16,$7}' > Ensembl_canonical_TSL123.lncRNA.bed

rm MANE_Select.protein_coding.gtf Ensembl_canonical_TSL123.lncRNA.gtf
```

Remove the black list and make windows for protein-coding and lncRNA files:

```{bash remove, eval = FALSE}
#!/usr/bin/sh

WORKING="."
blacklist="hg38-blacklist.v2.bed"
window=200

mkdir makewindow

## Removing black list and computes windows for protein-coding annotations
ANNOTATION="MANE_Select.protein_coding.bed"
awk -F "\t" -v OFS="\t" '{print $1,$2,$3,$4"_"$5"_"$6}' $ANNOTATION | bedtools intersect -a stdin -b $blacklist -v  | bedtools makewindows -n $window -i srcwinnum -b stdin | sort -k1,1 -k2,2n > $WORKING/makewindow/v43.MANE_protein.window${window}.bed
echo $WORKING/makewindow/v43.MANE_protein.window${window}.bed

## Removing black list and computes windows for lncRNA annotations
ANNOTATION="Ensembl_canonical_TSL123.lncRNA.bed"
awk -F "\t" -v OFS="\t" '{print $1,$2,$3,$4"_"$5"_"$6}' $ANNOTATION | bedtools intersect -a stdin -b $blacklist -v  | bedtools makewindows -n $window -i srcwinnum -b stdin | sort -k1,1 -k2,2n > $WORKING/makewindow/v43.Ensembl_canonical_TSL123.lncRNA.bed
echo $WORKING/makewindow/v43.Ensembl_canonical_TSL123.lncRNA.bed
```

For each bedgraph file, remove the black list and mappability track, and retrieve scores on the protein coding annotations:

```{bash bedgraph-protcod, eval = FALSE}
#!/usr/bin/zsh

ext="bg"
WORKING="."
window=200
umapk50="k50.umap.hg38.0.8.bed" # hg38 mappability windows with mapp k50 > 80%
blacklist="hg38-blacklist.v2.bed"

windowfiles=["makewindow/v43.MANE_protein.window${window}.bed" "makewindow/v43.Ensembl_canonical_TSL123.lncRNA.bed"]
annotationsfiles=["MANE_Select.protein_coding.bed" "Ensembl_canonical_TSL123.lncRNA.bed"]
namesvec=["protein-coding" "lncRNA"]
outputfolders=["protein_coding_score" "lncRNA_score"]

for i in ${#windowfiles[@]};
do
    echo "Processing "${namesvec[$i]}
    windowfile=${windowfiles[$i]}
    annofile=${annotationsfiles[$i]}
    outfoldname=${outputfolders[$i]}

    mkdir $WORKING/withzeros
    mkdir $WORKING/mapHigh

    for file in $WORKING/*.$ext ;
    do
        filename=$(basename "$file" .$ext);
        echo "starting file :"
        echo $filename;

        if echo $filename | egrep -q "reverse|minus" ;  then  
            strand="-"
        elif echo $filename | egrep -q "forward|plus" ; then
            strand='+'
        fi

        echo "removing blacklist region"
        bedtools intersect -a $WORKING/${filename}.$ext -b <( \
        awk -F "\t" -v OFS="\t" -v myvar=$strand '{if ($6==myvar) print $1,$2,$3,$4"_"$5"_"$6}' $annofile \
        | bedtools intersect -a stdin -b $blacklist -v) \
        | sort -k1,1 -k2,2n > $WORKING/withzeros/${filename}.nonzeros.$ext

        echo "removing low mappability region"
        bedtools intersect -a $WORKING/withzeros/${filename}.nonzeros.${ext} -b $umapk50 -sorted \
        | awk -F "\t" -v OFS="\t" '{print $1,$2,$3,".",$4}' > $WORKING/mapHigh/${filename}.0.8.$ext

        echo "scoring windows"
        bedmap --echo --wmean --delim "\t" $windowfile $WORKING/mapHigh/${filename}.0.8.$ext | awk -F "_" -v OFS="\t" '{print $1,$2,$3,$4}' | awk -F "\t" -v OFS="\t" -v name="$filename" '{ print $0,$4"_"$5"_"$6"_"$7,name}' | awk -F "\t" -v OFS="\t" '{ print "protein-coding",$1,$2,$3,$4,$5,$6,$7,$9,$10,$8 }' > $WORKING/${filename}.window${window}.MANE.wmean.name.score ;

        mkdir $WORKING/$outfoldname
        mv $WORKING/*.score $WORKING/$outfoldname/
        rm -r $WORKING/withzeros $WORKING/mapHigh
        echo "done"
    done
done
```

The package provides a `joinfiles` function to generate the final table that is used as input below. Running the function from the data folder, the default parameters can be used:

```{r mergefiles, eval = FALSE}
library(tepr)

alltsv <- joinfiles()

## Performing type conversion
idxvec <- c(8, 11, 13, 15, 17, 19, 21, 23, 25)
invisible(sapply(idxvec, function(idx) alltsv[, idx] <<- as.numeric(alltsv[, idx])))
```
