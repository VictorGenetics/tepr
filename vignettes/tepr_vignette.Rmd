---
title: "TepR: Transcription elongation profile in R"
author: "Victor Billon, Nicolas Descostes, and Gael Cristofari"
package: tepr
output:
    BiocStyle::html_document
vignette: >
    %\VignetteIndexEntry{tepr}
    %\VignetteEngine{knitr::rmarkdown}
    %\VignetteEncoding{UTF-8}
---


# Introduction

TepR (Transcription Elongation Profile in R) is an R package designed for analyzing data from nascent RNA sequencing technologies, such as TT-seq, mNET-seq, and PRO-seq.  It calculates the probability distribution of nascent RNA sequencing signal across the gene body or transcription unit of a given gene.  By comparing this profile to a uniform signal, TepR can identify transcription attenuation sites.  Furthermore, it can detect increased or decreased transcription attenuation by comparing profiles across different conditions.  Beyond its rigorous statistical testing and high sensitivity, a key strength of TepR is its ability to resolve the elongation pattern of individual genes, including the precise location of the primary attenuation point, when present.  This capability allows users to visualize and refine genome-wide aggregated analyses, enabling the robust identification of effects specific to gene subsets.  These metrics facilitate comparisons between genes within a condition, across conditions for the same gene, or against a theoretical model of perfect uniform elongation.

# Getting help

For any questions or bug reports, please open an [issue](https://github.com/retrogenomics/tepr/issues) on GitHub.

# Quick start

The following example demonstrates a complete run of the package. Preprocessing is performed on chromosome 13, and postprocessing is limited to the first 100 transcripts. The system.file command retrieves file paths from the package's "extdata" directory.

```{r quickstart, eval = FALSE}

library(tepr)

## Parameters (transpath limited to 100 transcripts)
exppath <-  system.file("extdata", "exptab.csv", package="tepr")
transpath <- system.file("extdata", "cugusi_100.tsv", package="tepr")
expthres <- 0.1
windsize <- 200

## Read input tables
expdf <- read.csv(exppath)
transdf <- read.delim(transpath, header = FALSE)

## Retrieving the bedgraph paths
bgpathvec <- sapply(expdf$path, function(x) system.file("extdata", x,
    package = "tepr"))

## Replace the path column of expdf with the previously retrieved paths
## and writing the new experiment file to the current folder
expdf$path <- bgpathvec
write.csv(expdf, file = "./exptab.csv", row.names = FALSE, quote = FALSE)
exppath <- "./exptab.csv"


#########
# Pre-processing - takes ~ 7 minutes
#########

gencodepath <- system.file("extdata", "gencode-chr13.gtf", package = "tepr")
maptrackpath <- system.file("extdata", "k50.umap.chr13.hg38.0.8.bed",
    package = "tepr")
blacklistshpath <- system.file("extdata", "hg38-blacklist-chr13.v2.bed",
    package = "tepr")
genomename <- "hg38"

finaltab <- preprocessing(exppath, gencodepath, windsize, maptrackpath,
    blacklistshpath, genomename, finaltabpath = "./", finaltabname = "anno.tsv",
    showtime = TRUE, verbose = TRUE)

#########
# tepr analysis - takes ~ 11 seconds
#########

reslist <- tepr(expdf, transdf, expthres, showtime = TRUE, verbose = TRUE)
resmeandiff <- reslist[[1]]
res <- reslist[[2]]
```

# Data

## Description

For a comprehensive analysis, we will use the data from [Cugusi et al.](https://doi.org/10.1016/j.molcel.2022.01.007). To validate our approach and explore the utility of TepR metrics in revealing gene-specific elongation characteristics, we re-analyzed previous experiments demonstrating that heat shock (HS) induces attenuation in human cultured cells.  We compared TT-seq data from HS-stressed and control MRC5-VA cells.  Stressed cells were cultured for 2 hours at 42°C, while control cells were maintained at 37°C.  Both samples were subjected to a 15-minute pulse of 4-thiouridine (4sU) labeling of nascent transcripts, followed by purification and sequencing.

## Download

The bedgraph files, mappability track and black list necessary for performing the entire analysis can be downloaded from zenodo:

```{bash raw-files, eval = FALSE}

TO DO
-----

#!/usr/bin/sh

mkdir data

wget https://ftp.ebi.ac.uk/pub/databases/gencode/Gencode_human/release_43/gencode.v43.basic.annotation.gtf.gz -P data/ && gunzip data/gencode.v43.basic.annotation.gtf.gz
wget https://github.com/Boyle-Lab/Blacklist/blob/master/lists/hg38-blacklist.v2.bed.gz -P data/ && gunzip data/hg38-blacklist.v2.bed.gz

* k50.umap.hg38.0.8.bed (k50.umap.hg38.0.8.bed) - sent by victor
* ctrl_rep1.forward.bg (ctrl_rep1.forward.bg) - sent by victor
* ctrl_rep1.reverse.bg (ctrl_rep1.reverse.bg) - sent by victor
* ctrl_rep2.forward.bg (ctrl_rep2.forward.bg) - sent by victor
* ctrl_rep2.reverse.bg (ctrl_rep2.reverse.bg) - sent by victor
* HS_rep1.forward.bg (HS_rep1.forward.bg) - sent by victor
* HS_rep1.reverse.bg (HS_rep1.reverse.bg) - sent by victor
* HS_rep2.forward.bg (HS_rep2.forward.bg) - sent by victor
* HS_rep2.reverse.bg (HS_rep2.reverse.bg) - sent by victor

```

If one would like to skip the preprocessing, the preprocessing result file can be downloaded with:

```{bash cugusi-table, eval = FALSE}

TO DO
```


# Standard workflow

## Preprocessing

The preprocessing pipeline consists of the following steps:

1.  Filtering Gencode annotations to extract "transcript" annotations.
2.  Distinguishing between protein-coding (MANE_Select) and long non-coding (lncRNA, Ensembl_canonical) transcripts.
3.  Dividing transcripts into windows of a user-defined size (`windsize`).
4.  Processing bedgraph files to retrieve signal values, excluding blacklisted regions, and retaining scores within high-mappability intervals.
5.  Generating a final annotated table incorporating the scores derived from the preceding steps.

**Important:** The `preprocessing` function allows for saving intermediate objects, which prevents recomputation in cases of failure due to memory or time constraints.  See the `saveobjectpath` and `deletetmp` parameters in the `?preprocessing` help documentation for details.  Resource requirements for processing the complete dataset are provided below.

| nb CPU | RAM | Time |
|--------|-----|------|
| 15 | 113.5 G | 3h47 |
| 10 | 78.9 G | 4h24 |
| 7 | 57.4 G | 5h27 |
| 5 | 43G | 6h58 |
| 3 | 28.7G | 9h02|

The code below is executed on chromosome 13 only to reduce computation time.

### Input files

The following input files are required for the analysis:

*   **exptab:** A table describing the experiments, containing the columns "condition," "replicate," "direction," "strand," and "path." The "direction" column should contain the values "forward" and "reverse," and the "strand" column should contain "plus" and "minus."  The `checkexptab` utility function can be used to verify the table's format.
*   **gencode:** The Gencode annotation file, available at [https://www.gencodegenes.org/](https://www.gencodegenes.org/).
*   **maptrack:** Files containing low-mappability intervals for the genome of interest. For hg38, the track [k50.Unique.Mappability.bb](https://hgdownload.soe.ucsc.edu/gbdb/hg38/hoffmanMappability/k50.Unique.Mappability.bb) was downloaded from the UCSC server, and scores below 0.8 were set to `NA`.
*   **blacklist:** Blacklist files for various organisms are available at [https://github.com/Boyle-Lab/Blacklist/blob/master/lists/](https://github.com/Boyle-Lab/Blacklist/blob/master/lists/).


### Retrieving Transcript Annotations from Gencode

The `retrieveanno` function performs the following steps:

1.  Reads and validates experimental data from the provided `exptab` CSV file.
2.  Reads genomic annotations from the Gencode file and filters for "transcript" entries.
3.  Processes protein-coding and long non-coding RNA (lncRNA) transcripts separately:
    *   For protein-coding genes, it selects the most representative transcript (MANE_Select or Ensembl_canonical).
    *   For lncRNAs, it filters out transcripts with undesirable evidence levels (containing keywords "not_best_in_genome_evidence," "transcript_support_level 5," or "transcript_support_level 4").
4.  Combines the processed annotations into a single data frame, labeling each transcript with its biotype (protein-coding or lncRNA).
5.  Optionally saves the resulting data frame as an RDS file in the specified `saveobjectpath` directory.
6.  Optionally reports the total analysis time (if `showtime = TRUE`).


```{r retrieveanno}
library(tepr)

## Parameters
exptabpath <-  system.file("extdata", "exptab.csv", package="tepr")
gencodepath <- system.file("extdata", "gencode-chr13.gtf", package = "tepr")

allannobed <- retrieveanno(exptabpath, gencodepath)
message("\n The result is:\n")
print(head(allannobed, 3))
```

### Defining Windows for Each Transcript

The `makewindows` function performs the following operations:

1.  Removes any Ensembl transcript names containing "PAR_Y."
2.  Filters out intervals smaller than `windsize`.
3.  Divides each remaining transcript into windows of size `windsize`.

The output includes metadata for each window, such as its chromosome, start and end coordinates, associated gene, and window number.

```{r makewindows}
## Parameters
windsize = 200

allwindowsbed <- makewindows(allannobed, windsize)
message("\n The result is:\n")
print(head(allwindowsbed, 3))
```

### Retrieving Bedgraph Scores and Filtering Blacklisted and Low-Mappability Regions

The `blacklisthighmap` function iterates through each chromosome, processing genomic scores by removing those that overlap with blacklisted and low-mappability regions. It also calculates weighted means for scores within each window.  This function leverages parallel processing for efficiency and supports saving (`saveobjectpath`) and reloading (`reload`) intermediate results to optimize the workflow.

The main steps include:

*   Reading and processing bedGraph values.
*   Removing scores overlapping with blacklisted and low-mappability regions.
*   Calculating weighted means for overlapping scores within each genomic window.
*   Saving the processed results to a specified temporary folder (`tmpfold`).

Note that this function does not return a value; instead, it saves the processed files to a temporary folder for use by the subsequent `createtablescores` function.

```{r blacklisthighmap, eval = FALSE}
## Parameters
maptrackpath <- system.file("extdata", "k50.umap.chr13.hg38.0.8.bed", package = "tepr")
blacklistshpath <- system.file("extdata", "hg38-blacklist-chr13.v2.bed", package = "tepr")
nbcputrans <- 1
genomename <- "hg38"
tmpfolder <- "./tmp"

## The path to the bedgraph files provided with the package depends on your installation. Modify exptab with the\
## correct path and create a new file in the current folder.
## IMPORTANT: You can skip these steps if your exptab contains the correct paths
expdf <- read.csv(exptabpath)
bgpathvec <- sapply(expdf$path, function(x) system.file("extdata", x,
    package = "tepr"))
expdf$path <- bgpathvec
write.csv(expdf, file = "./exptab.csv", row.names = FALSE, quote = FALSE)
exptabpath <- "./exptab.csv"

## Retrieving bedgraph scores, removing those in black list and low mappability intervals
blacklisthighmap(maptrackpath, blacklistshpath, exptabpath, nbcputrans, allwindowsbed, windsize, genomename, tmpfold = tmpfolder)
```

### Creating the Final Table

The `createtablescores` function merges the files stored in `tmpfolder` that belong to the same experiment and direction. These files are combined into a single table, with two columns per experiment: one containing the experiment name and the other containing the corresponding scores. The resulting table also includes annotations for each transcript.

```{r createtablescores, eval = FALSE}
finaltab <- createtablescores(tmpfolder, exptabpath, savefinaltable = FALSE)
```

The final table should look like:

```{r showfinaltab, echo = FALSE}
finaltabpath <- system.file("extdata", "finaltab-chr13.tsv", package = "tepr")
finaltab <- read.delim(finaltabpath, header = FALSE)
print(finaltab)
```



## TepR Analysis

The quick start section demonstrates how to perform a TepR analysis in a single call using the `tepr` function.  Below, we detail the individual steps performed by `tepr` using a subset of 100 transcripts for demonstration purposes.  Plots generated from the complete annotation dataset are also provided. The complete table resulting from preprocessing can be downloaded [here](TO DO). See section 6.1 for notes on processing the complete dataset.

### Input Files

Two tables are required as input:

*   **transdf:** The table generated by the `preprocessing` function (described in previous sections). This table contains information about each experiment, along with scores for each protein-coding and lncRNA annotation.

*   **exptab:** A table describing the experiments, containing the columns "condition", "replicate", "direction", "strand", and "path". The "direction" column should contain the values "forward" and "reverse", and the "strand" column should contain "plus" and "minus". You can verify the table's format using the `checkexptab` utility function.

These two tables are included with the package and can be accessed using the `system.file` command within the "extdata" directory.  For this demonstration, we have sampled 100 transcripts from the `transdf` table to reduce computation time.

```{r reading-anno-scores}
transpath <- system.file("extdata", "cugusi_100.tsv", package="tepr")
transdf <- read.delim(transpath, header = FALSE)
colnames(transdf) <- c("biotype", "chr", "coor1", "coor2", "transcript", "gene",
    "strand", "window", "id", "ctrl_rep1.plus", "ctrl_rep1.plus_score",
    "ctrl_rep1.minus", "ctrl_rep1.minus_score", "ctrl_rep2.plus",
    "ctrl_rep2.plus_score", "ctrl_rep2.minus", "ctrl_rep2.minus_score",
    "HS_rep1.plus", "HS_rep1.plus_score", "HS_rep1.minus",
    "HS_rep1.minus_score", "HS_rep2.plus", "HS_rep2.plus_score",
    "HS_rep2.minus", "HS_rep2.minus_score")
print(head(transdf, 3))

## The second table contains information about each replicate:
exppath <- system.file("extdata", "exptab.csv", package="tepr")
expdf <- read.csv(exppath)
head(expdf)
```

You can verify the table's format using the `checkexptab` utility function.  Note that this verification is also performed by `averageandfilterexprs`.

```{r checkexptab}
checkexptab(expdf)
```

### Expressed Transcripts and Average Expression

To study changes in nascent RNA patterns, the initial step is to select expressed transcripts. The expression value of a gene is defined as the mean score across both strands. These scores are derived from the bedgraph files. A gene is considered expressed if its mean expression in all conditions exceeds a specified threshold.  The default expression threshold is set to 0.1.

```{r averageandfilterexprs}
## Calculate Average Expression and Filter Transcript Data
expthres <- 0.1
resallexprs <- averageandfilterexprs(expdf, transdf, expthres)
```

`resallexprs` is a list.  Its first element is the input `transdf` with additional columns, such as the calculated mean expression values. The second element is a vector containing the IDs of the transcripts considered expressed. This vector will be used in subsequent downstream analyses.

```{r exprsvec}
## Print the first 6 expressed transcripts
head(resallexprs[[2]])
```

### NA Values per Transcript and Condition

During preprocessing, scores within user-defined blacklisted regions, low-mappability regions, or any other excluded regions are replaced with NA values. The `countna` function retrieves the number of missing scores for each transcript. This table can be used for further data filtering, such as removing transcripts with an excessive number of windows lacking scores.

```{r countna}
## Count NA values per transcript and condition
rescountna <- countna(resallexprs, expdf)
head(rescountna)
```

### Empirical Cumulative Distribution Function (ECDF) for Genes

This function calculates the empirical cumulative distribution function (ECDF) for expressed genes across their transcripts.  An ECDF is a probability distribution that estimates the Cumulative Distribution Function; here, we use the `ecdf()` function from R. It generates an ECDF for each transcript, which are then used to assess differences in signal using a Kolmogorov-Smirnov test. The ECDF helps answer the question: How likely is it that we would observe a distribution of signals like this if the signals were drawn from a uniform probability distribution? In other words, this statistic helps identify specific loci where the transcription signal deviates significantly from a uniform density.  In the following steps, the ECDF is used to compute the difference from the cumulative distribution (see `meananddifference`), which is subsequently used to calculate the area under the curve (AUC, see `allauc`) and the inflection point or knee (see `kneeid`).

```{r ecdf}
## Compute ECDF for Genes Based on Expression Data
resecdflist <- genesECDF(resallexprs, expdf)
```

The `genesECDF` function returns a list. The first element is the main table with added ECDF columns, prefixed with `Fx`.

```{r resecdf}
resecdf <- resecdflist[[1]]
print(head(as.data.frame(resecdf), 3))
```

The second element returns the number of windows per transcript, which is set to 200 by default during preprocessing.

```{r nbwindows}
nbwindows <- resecdflist[[2]]
print(nbwindows)
```

### Mean and Differences of Scores for Each Condition

The `meandifference` function computes three types of statistics: mean score values, the ECDF for each replicate (if provided), and the difference between the mean ECDF and the uniform cumulative distribution.  Mean values across replicates are calculated, resulting in one `mean_value` column per condition. These `mean_value` score columns are required for subsequent attenuation score calculations (see `attenuation`). The mean ECDF values are used to calculate the difference from the cumulative distribution, which we term *diff_Fx*. The *diff_Fx* statistic is used to calculate the area under the curve (AUC, see `allauc`) and the inflection point or *knee* (see `kneeid`).

The difference is calculated as: *diff_Fx = meanECDF - cumvec / nbwindows*

```{r meandifference}
## Compute Mean and Differences of Scores for Each Condition
resmeandiff <- meandifference(resecdf, expdf, nbwindows)
print(head(resmeandiff, 3))
```

The resulting table is then split into a list of tables, one per transcript. This enables parallel processing by transcript for subsequent operations if multiple CPUs are available.

```{r splitmeans}
## Split the results by transcripts
bytranslistmean <- split(resmeandiff, factor(resmeandiff$transcript))
```

### Area Under the Curve (AUC) and Differences in AUC for Transcript Data

The Area Under the Curve (AUC) values enable comparison of the nascent RNA signal to a uniform distribution (representing no signal attenuation, where x = y) or comparison of the difference in signal distribution between two conditions (dAUC). The difference between cumulative densities is estimated using a Kolmogorov-Smirnov test with adjusted p-value. Finally, results are returned by transcript, along with a mean value termed *MeanValueFull*.

For each condition (if more than one), the AUC of *diff_Fx* (described in the previous section) is computed using a trapezoidal approximation (see `pracma::trapz`):

*AUC = pracma::trapz(transcoord, diff_Fx)*

where `transcoord` represents the positions along the transcript and *diff_Fx* is the difference from the cumulative distribution.

```{r allauc}
## Calculate Area Under Curve (AUC) and Differences of AUC for Transcript Data
resauc <- allauc(bytranslistmean, expdf, nbwindows)
print(head(resauc, 3))
```

### Knee and Max ECDF Differences for Each Transcript

To assess attenuation in the nascent RNA signal, it's necessary to identify significant changes in signal distribution. TepR accomplishes this by identifying the maximum *diff_Fx*. In other words, it pinpoints the greatest variation in the signal progression of the empirical cumulative distribution (see `genesECDF` and `meandifference`). The window where this maximum change occurs is termed the *knee* and is calculated as: *knee = max(diff_Fx)*. Thus, the knee position is defined as the maximum difference between the ECDF and the y=x curve.

The function returns both the position (*Knee_AUC*) and the value (*diff_Fx*) of the knee.

```{r knee}
## Identify the Knee and Max ECDF Differences for Each Transcript
resknee <- kneeid(bytranslistmean, expdf)
print(head(resknee))
```

### Attenuation

The `attenuation` function calculates the mean score of all window means *before* the knee location and the mean score of all window means *after* the knee location. It then calculates an "attenuation score" using the following formula: *att <- 100 - (downmean / upmean) x 100* (x for multiplication). The function returns three values, stored in the columns "UP_mean_," "DOWN_mean_," and "Attenuation_," representing *att*, *downmean*, and *upmean*, respectively.

```{r attenuation}
## Calculate Attenuation from AUC and Other Transcript Features
resatt <- attenuation(resauc, resknee, rescountna, bytranslistmean, expdf,
    resmeandiff)
print(head(resatt, 3))
```

### Defining the Universe and Groups

**Universe**

Prior to further downstream analysis, the set of transcripts to be studied must be defined. These transcripts are designated as belonging to the "Universe." TepR selects a transcript for inclusion in the Universe if it meets the following criteria:

1.  Its windows are sufficiently long.
2.  It does not contain too many missing values (NA).
3.  Its mean expression value is sufficiently high.
4.  It has a significant Kolmogorov-Smirnov test adjusted p-value. This test compares the ECDF distribution to the theoretical cumulative distribution.

Analytically, this can be represented as:

```{r uniselect, eval = FALSE}
window_size > windsizethreshold &
Count_NA < countnathreshold &
meanctrl > meanctrlthreshold &
meanstress > meanstressthreshold &
pvaltheory > pvaltheorythres
```

If only one condition is provided, only the control threshold is used:

```{r uniselectonecond, eval = FALSE}
window_size > windsizethreshold &
Count_NA < countnathreshold &
meanctrl > meanctrlthreshold &
pvaltheory > pvaltheorythres
```

Appropriate threshold values for each criterion depend on the specific experiments. The user can adjust these thresholds throughout the analysis. A transcript that satisfies the above criteria is defined as belonging to the "Universe" of transcripts to be analyzed. The `Universe` column in the data will contain `TRUE` or `FALSE` to indicate membership.

**Groups**

The transcripts in the Universe are further categorized into Groups. A transcript belongs to the "Attenuated" group if it meets the following criteria:

1.  It belongs to the Universe (`Universe == TRUE`).
2.  Its "stress" AUC value is sufficiently high.
3.  The negative base-10 logarithm of the adjusted p-value from the Kolmogorov-Smirnov test exceeds a given threshold.

Analytically, this is represented as:

```{r attselect, eval = FALSE}
Universe == TRUE &
aucstress > aucstressthreshold &
-log10(pvalks) > attenuatedpvalksthreshold
```

If only one condition is provided, no comparison via the Kolmogorov-Smirnov test with another condition is performed. A transcript will be considered attenuated if it deviates significantly from the theoretical cumulative distribution *and* its AUC value is sufficiently high. The significant deviation has already been evaluated during the Universe calculation (`pvaltheory > pvaltheorythres`). Therefore, with only one condition, a transcript is considered attenuated if:

```{r attselectonecond, eval = FALSE}
Universe == TRUE & aucctrl > aucctrlthreslower
```

A transcript is considered non-attenuated ("Outgroup") if it meets the following criteria:

1.  The Kolmogorov-Smirnov adjusted p-value is above a specified threshold.
2.  The control AUC falls between two user-defined thresholds.

Analytically, this is represented as:

```{r outgroup, eval = FALSE}
Universe == TRUE & pvalks > outgrouppvalksthreshold &
aucctrl > aucctrlthresoldhigher & aucctrl < aucctrlthresholdlower
```

For a single-condition analysis, where no Kolmogorov-Smirnov test against another condition is performed, a transcript belongs to the "Outgroup" if it belongs to the Universe *and* its control AUC falls between two user-defined thresholds:

```{r outgroup2, eval = FALSE}
Universe == TRUE & aucctrl > aucctrlthresoldhigher & aucctrl < aucctrlthresholdlower
```

Note that transcripts belonging to neither "Attenuated" nor "Outgroup" are assigned NA to the `Group` column. The `Universe` and `Group` columns are computed as follows:

```{r universegroup}
## Define Universe and Group of Genes Based on Expression Data
res <- universegroup(resatt, expdf)
print(head(res, 2))
```

## Plotting

TepR provides visualization capabilities for: the cumulative transcription density along a selected transcription unit (`plotecdf`); the comparison of AUC between two conditions (`plotauc`); the average transcription density of a user-selected set of transcripts (`plotmetagenes`); and a histogram of the distance between knees and transcription start sites (TSS).

### `plotecdf`

The empirical cumulative distribution function (ECDF) for a specific transcript (EGFR in this example) can be visualized using:

```{r plotecdf}
colvec <- c("#90AFBB", "#10AFBB", "#FF9A04", "#FC4E07")
plotecdf(resmeandiff, res, expdf, "EGFR", colvec, plot = TRUE)
```

### `plotauc`

AUC values between conditions can be compared by highlighting the two conditions on the plot:

```{r plotaucgroups}
plotauc(res, expdf, plottype = "groups", plot = TRUE)
```

The plot generated using the complete dataset is shown below:

[AUC group plot](pictures/AUCcompare_group.png)

It is also possible to compare the AUC by coloring points according to the Kolmogorov-Smirnov test adjusted p-values and by indicating graphically the points corresponding to a group of genes (here defined by `genevec`):

```{r plotaucpval}
genevec <- c("EGFR", "DAP", "FLI1", "MARCHF6", "LINC01619")
plotauc(res, expdf, genevec, plot = TRUE)
```

The plot generated using the complete dataset is shown below:

<img src="pictures/AUCcompare_pval.png" alt="AUC pval plot" width="400"/>

### plotmetagenes

The average transcription density along a meta-transcript or a meta-gene can be visualized with:

```{r metageneplot}
plotmetagenes(res, resmeandiff, expdf, plottype = "attenuation", plot = TRUE)
```

The plot on the complete dataset gives:

<img src="pictures/metagene_attenuation.png" alt="Attenuation meta" width="400"/>

Note that the second parameter tells to plot the distribution for the transcripts identified as "attenuated" by the function `universegroup`. The function also enables to select the transcripts categorized as "outgroup", all the transcripts belonging to the "universe", or all the transcripts of the initial table ("all").

### plothistoknee

One can visualize the distance of the knees from the TSS by percentage:

```{r kneepercent}
plothistoknee(res, plot = TRUE)
```

The plot on the complete dataset gives:

<img src="pictures/histo_percent.png" alt="histo percent" width="400"/>

The distance can also be visualised in kilobases (kb) by changing the *plottype* parameter to "kb":

```{r kneekb}
plothistoknee(res, plottype = "kb", plot = TRUE)
```

The plot on the complete dataset gives:

<img src="pictures/histo_kb.png" alt="histo kb" width="400"/>

## More than two conditions

### teprmulti analysis

It is possible to analyze more than two experiments with the function `teprmulti`. This function performs a "all vs all" analysis and returns a list whose elements, for each comparison, is a list of two data frames: 

- `resmeandiff_<comparison>`: Results of the `meandifference` function for the specific two condition comparison.
- `resunigroupatt_<comparison>`: Results from the `universegroup` function for the specific two condition comparison. 

```{r teprmulti, eval = FALSE}
resteprmulti <- teprmulti(expdf, transdf, expthres)
```

The function `showallcomp` enables to return a vector of all comparison names that will be performed by `teprmulti`. This gives the possibility to reduce the number of comparisons by using the `dontcompare` parameter. `dontcompare` takes a vector of all the comparisons to exclude. The code below limits teprmulti to three comparisons:

```{r teprmultithree, eval = FALSE}
## Returns a vector with all the comparison names to exclude
dontcompvec <- showallcomp(expdf)
dontcompvec <- dontcompvec[- c(1,2,3)]

resteprmulti <- teprmulti(expdf, transdf, expthres, dontcompare = dontcompvec)
```


### plotmulti

Using the result list `resteprmulti`, all plots for all comparisons can be generated with `plotmulti`. The function goes through each element of `resteprmulti` which corresponds to a comparison of two conditions. For each element it calls the following functions:

- `plotecdf`: The function generates a figure for each gene given in ecdfgenevec.
- `plotauc`: Generates figures by groups and pval. The lattest figure is not generated if genaucvec = NA.
- `plotmetagenes`: Generates the figures by attenuation, outgroup, universe, and all.
- `plothistoknee`: Generate the figures by percent and kb.

Figures are written to `outfold` and subfolders are automatically created with the names of the comparisons.

```{r plotmulti, eval = FALSE}
plotmulti(resteprmulti, expdf, ecdfgenevec = c("CDC27", "BCAR1", "TRAM2"), outfold = "./multicomp")
```

### Calculating knee for each condition

The function `kneeallconds` aims at retrieving knee values without having to perform the entire `teprmulti` analysis. It computes the knee values `knee_AUC_` and `max_diff_Fx_` for each condition separately.

```{r kneeallconds, eval = FALSE}
kneedf <- kneeallconds(alldf, expdf, expthres)
```


## Single condition

If your dataset contains only one condition, either with one or more than one replicate, it is possible to analyse the data by comparing the signal to a linear "theoretical" distribution representing a uniform signal. The difference of means and AUC are skipped when running `meandifference` and `allauc`. The criterion to define the columns "Universe" and "Group" are also different (see details in previous section). 

```{r singlecond}
## The experiment table is limited to one condition and one replicate
expdfonecond <- expdf[which(expdf$condition == "HS" & expdf$replicate == 1), ]

## The table obtained by preprocessing is limited to the condition 'HS' and replicate 1
transdfonecond <- transdf[, c(seq_len(9), 18, 19, 20, 21)]

## Computing the object 'res' with tepr on one condition
resonecond <- tepr(expdfonecond, transdfonecond, expthres, controlcondname = "HS", verbose = FALSE)
```

The AUC and metagene plots require two conditions and thus cannot be generated. The ecdf on a given gene can be obtained with:

```{r ecdfcond}
plotecdf(resonecond[[1]], resonecond[[2]], expdfonecond, genename = "EGFR",
    colvec = c("#90AFBB"), plot = TRUE)
```

The histogram of knee positions can be obtained with:

```{r histocond}
## Randomly marking 10 transcripts as attenuated as a mock example
idxatt <- sample(seq_len(100), 10)
resonecond[[2]][idxatt, "Group"] <- "Attenuated"
plothistoknee(resonecond[[2]], kneename = "knee_AUC_HS", plottype = "percent", plot = TRUE)
```

# Annex

## Note on processing the complete dataset

Note that parallelization is encouraged on the complete dataset. We used 20 cpus. The code below assumes that the file "dTAG_Cugusi_stranded_20230810.tsv" is in the current folder. Note that you can check the conformity of the table `transdf` with the utility function `checkexptab`. 

The time of computation for each function is indicated:

```{r completedataset, eval = FALSE}
library(tepr)

transpath <- "dTAG_Cugusi_stranded_20230810.tsv"
exppath <- system.file("extdata", "exptab.csv", package="tepr")

## Reading input files
transdf <- read.delim(transpath, header = FALSE) 
expdf <- read.csv(exppath)

## Calculate Average Expression and Filter Transcript Data
expthres <- 0.1
resallexprs <- averageandfilterexprs(expdf, transdf, expthres, showtime = TRUE)

         Calculating average expression per transcript
         Removing lines with values < expthres
                 ## Analysis performed in: 7.67012810707092 (seconds)

## Count NA values per transcript and condition
rescountna <- countna(resallexprs, expdf, nbcpu = 20, showtime = TRUE)

         Splitting the table by each transcript
                 ## Analysis performed in: 25.9511797428131 (seconds)

## Compute ECDF for Genes Based on Expression Data
resecdflist <- genesECDF(resallexprs, expdf, nbcpu = 20, showtime = TRUE)

         Filtering to keep only the expressed transcripts
         Splitting the table by each transcript
         Computing ecdf on each transcript
                 ## Analysis performed in: 1.23920369148254 (minutes)
resecdf <- resecdflist[[1]]
nbwindows <- resecdflist[[2]]

## Compute Mean and Differences of Scores for Each Condition
resmeandiff <- meandifference(resecdf, expdf, nbwindows, showtime = TRUE)

         Merging columns for condition ctrl
         Calculating average and difference between replicates for columns 'value' of ctrl
         Calculating average and difference between replicates for columns 'Fx' of ctrl
         Merging columns for condition HS
         Calculating average and difference between replicates for columns 'value' of HS
         Calculating average and difference between replicates for columns 'Fx' of HS
         Commputing all differences on mean columns
                 ## Analysis performed in: 0.953349590301514 (seconds)

## Split the results by transcripts
start_time <- Sys.time()
bytranslistmean <- split(resmeandiff, factor(resmeandiff$transcript))
end_time <- Sys.time()
message("\t\t ## Analysis performed in: ", end_time - start_time)

                ## Analysis performed in: 6.54691791534424 (seconds)

## Calculate Area Under Curve (AUC) and Differences of AUC for Transcript Data
resauc <- allauc(bytranslistmean, expdf, nbwindows, nbcpu = 20, showtime = TRUE)

         Computing the differences (d or delta) of AUC
         Computing the Area Under Curve (AUC)
         Merging results
                 ## Analysis performed in: 27.2096176147461 (seconds)

## Identify the Knee and Max ECDF Differences for Each Transcript
resknee <- kneeid(bytranslistmean, expdf, nbcpu = 20, showtime = TRUE)

                 ## Analysis performed in: 11.8020555973053 (seconds)

## Calculate Attenuation from AUC and Other Transcript Features
resatt <- attenuation(resauc, resknee, rescountna, bytranslistmean, expdf,
    resmeandiff, nbcpu = 20, showtime = TRUE)

         Merging tables
         Building summary
         Merging summary
         Merging detailed mean table with summary
         Splitting the previous table by transcript
         Computing up and down mean
         Merging attenuation to the complete table
                 ## Analysis performed in: 1.17459278106689 (minutes)

## Define Universe and Group of Genes Based on Expression Data
res <- universegroup(resatt, showtime = TRUE)

         Computing the Universe column
         Computing the Group column
                          ## Analysis performed in: 0.0214207172393799 (seconds)

## Plotting and saving to current folder
colvec <- c("#90AFBB", "#10AFBB", "#FF9A04", "#FC4E07")
plotecdf(resmeandiff, res, expdf, "EGFR", colvec, outfold = ".",
    formatname = "png")

plotauc(res, expdf, plottype = "groups", outfile = "AUCcompare_group", outfold = ".",
    formatname = "png")
genevec <- c("EGFR", "DAP", "FLI1", "MARCHF6", "LINC01619")
plotauc(res, expdf, genevec, plottype = "pval", outfile = "AUCcompare_pval",
    outfold = ".", formatname = "png")

plotmetagenes(res, resmeandiff, expdf, plottype = "attenuation", formatname = "png",
    outfold = ".")

plothistoknee(res, outfold = ".", formatname = "png")
plothistoknee(res, plottype = "kb", outfold = ".", formatname = "png")
```


## Preprocessing with bash

To perform the pre-processing steps, we provide a conda environment that can be activated with:

```{bash conda, eval = FALSE}
TO DO
```

Retrieve the protein-coding and long non-coding RNA (lncRNA) annotations from the gencode file:

```{bash protcod-lncrna, eval = FALSE}
#!/usr/bin/sh

cd data/

## Building the protein-coding bed file
grep -w transcript gencode.v43.basic.annotation.gtf | grep -w MANE_Select > MANE_Select.protein_coding.gtf
awk 'OFS="\t" {print $0}' MANE_Select.protein_coding.gtf | tr -d '";' | sort -k1,1 -k2,2n  | awk -F \t -v OFS='\t' '{print $0}' | awk -v OFS="\t" '{ print $1,$4,$5,$12,$16,$7}' > MANE_Select.protein_coding.bed

## Building the lncRNA bed file
grep -w transcript gencode.v43.basic.annotation.gtf | grep -w lncRNA | grep -w Ensembl_canonical | grep -v not_best_in_genome_evidence | grep -v 'transcript_support_level "5"' | grep -v 'transcript_support_level "4"' > Ensembl_canonical_TSL123.lncRNA.gtf
awk 'OFS="\t" {print $0}' Ensembl_canonical_TSL123.lncRNA.gtf | tr -d '";' | sort -k1,1 -k2,2n  | awk -F \t -v OFS='\t' '{print $0}' | awk -v OFS="\t" '{ print $1,$4,$5,$12,$16,$7}' > Ensembl_canonical_TSL123.lncRNA.bed

rm MANE_Select.protein_coding.gtf Ensembl_canonical_TSL123.lncRNA.gtf
```

Remove the black list and make windows for protein-coding and lncRNA files:

```{bash remove, eval = FALSE}
#!/usr/bin/sh

WORKING="."
blacklist="hg38-blacklist.v2.bed"
window=200

mkdir makewindow

## Removing black list and computes windows for protein-coding annotations
ANNOTATION="MANE_Select.protein_coding.bed"
awk -F "\t" -v OFS="\t" '{print $1,$2,$3,$4"_"$5"_"$6}' $ANNOTATION | bedtools intersect -a stdin -b $blacklist -v  | bedtools makewindows -n $window -i srcwinnum -b stdin | sort -k1,1 -k2,2n > $WORKING/makewindow/v43.MANE_protein.window${window}.bed
echo $WORKING/makewindow/v43.MANE_protein.window${window}.bed

## Removing black list and computes windows for lncRNA annotations
ANNOTATION="Ensembl_canonical_TSL123.lncRNA.bed"
awk -F "\t" -v OFS="\t" '{print $1,$2,$3,$4"_"$5"_"$6}' $ANNOTATION | bedtools intersect -a stdin -b $blacklist -v  | bedtools makewindows -n $window -i srcwinnum -b stdin | sort -k1,1 -k2,2n > $WORKING/makewindow/v43.Ensembl_canonical_TSL123.lncRNA.bed
echo $WORKING/makewindow/v43.Ensembl_canonical_TSL123.lncRNA.bed
```

For each bedgraph file, remove the black list and mappability track, and retrieve scores on the protein coding annotations:

```{bash bedgraph-protcod, eval = FALSE}
#!/usr/bin/zsh

ext="bg"
WORKING="."
window=200
umapk50="k50.umap.hg38.0.8.bed" # hg38 mappability windows with mapp k50 > 80%
blacklist="hg38-blacklist.v2.bed"

windowfiles=["makewindow/v43.MANE_protein.window${window}.bed" "makewindow/v43.Ensembl_canonical_TSL123.lncRNA.bed"]
annotationsfiles=["MANE_Select.protein_coding.bed" "Ensembl_canonical_TSL123.lncRNA.bed"]
namesvec=["protein-coding" "lncRNA"]
outputfolders=["protein_coding_score" "lncRNA_score"]

for i in ${#windowfiles[@]};
do
    echo "Processing "${namesvec[$i]}
    windowfile=${windowfiles[$i]}
    annofile=${annotationsfiles[$i]}
    outfoldname=${outputfolders[$i]}

    mkdir $WORKING/withzeros
    mkdir $WORKING/mapHigh

    for file in $WORKING/*.$ext ;
    do
        filename=$(basename "$file" .$ext);
        echo "starting file :"
        echo $filename;

        if echo $filename | egrep -q "reverse|minus" ;  then  
            strand="-"
        elif echo $filename | egrep -q "forward|plus" ; then
            strand='+'
        fi

        echo "removing blacklist region"
        bedtools intersect -a $WORKING/${filename}.$ext -b <( \
        awk -F "\t" -v OFS="\t" -v myvar=$strand '{if ($6==myvar) print $1,$2,$3,$4"_"$5"_"$6}' $annofile \
        | bedtools intersect -a stdin -b $blacklist -v) \
        | sort -k1,1 -k2,2n > $WORKING/withzeros/${filename}.nonzeros.$ext

        echo "removing low mappability region"
        bedtools intersect -a $WORKING/withzeros/${filename}.nonzeros.${ext} -b $umapk50 -sorted \
        | awk -F "\t" -v OFS="\t" '{print $1,$2,$3,".",$4}' > $WORKING/mapHigh/${filename}.0.8.$ext

        echo "scoring windows"
        bedmap --echo --wmean --delim "\t" $windowfile $WORKING/mapHigh/${filename}.0.8.$ext | awk -F "_" -v OFS="\t" '{print $1,$2,$3,$4}' | awk -F "\t" -v OFS="\t" -v name="$filename" '{ print $0,$4"_"$5"_"$6"_"$7,name}' | awk -F "\t" -v OFS="\t" '{ print "protein-coding",$1,$2,$3,$4,$5,$6,$7,$9,$10,$8 }' > $WORKING/${filename}.window${window}.MANE.wmean.name.score ;

        mkdir $WORKING/$outfoldname
        mv $WORKING/*.score $WORKING/$outfoldname/
        rm -r $WORKING/withzeros $WORKING/mapHigh
        echo "done"
    done
done
```

The package provides a `joinfiles` function to generate the final table that is used as input below. Running the function from the data folder, the default parameters can be used:

```{r mergefiles, eval = FALSE}
library(tepr)

alltsv <- joinfiles()

## Performing type conversion
idxvec <- c(8, 11, 13, 15, 17, 19, 21, 23, 25)
invisible(sapply(idxvec, function(idx) alltsv[, idx] <<- as.numeric(alltsv[, idx])))
```
